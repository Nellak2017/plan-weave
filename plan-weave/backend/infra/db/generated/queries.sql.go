// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addTask = `-- name: AddTask :one
INSERT INTO tasks (
    id, user_id, task, selected, ttc, live_time, due_date,
    efficiency, parent_thread, waste, eta, weight, status,
    live_time_stamp, last_complete_time, last_incomplete_time, is_live
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17
)
RETURNING id
`

type AddTaskParams struct {
	ID                 int64
	UserID             uuid.UUID
	Task               string
	Selected           bool
	Ttc                float64
	LiveTime           float64
	DueDate            time.Time
	Efficiency         float64
	ParentThread       string
	Waste              float64
	Eta                time.Time
	Weight             int32
	Status             string
	LiveTimeStamp      sql.NullTime
	LastCompleteTime   time.Time
	LastIncompleteTime time.Time
	IsLive             bool
}

func (q *Queries) AddTask(ctx context.Context, arg AddTaskParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addTask,
		arg.ID,
		arg.UserID,
		arg.Task,
		arg.Selected,
		arg.Ttc,
		arg.LiveTime,
		arg.DueDate,
		arg.Efficiency,
		arg.ParentThread,
		arg.Waste,
		arg.Eta,
		arg.Weight,
		arg.Status,
		arg.LiveTimeStamp,
		arg.LastCompleteTime,
		arg.LastIncompleteTime,
		arg.IsLive,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addTaskDependencies = `-- name: AddTaskDependencies :many
INSERT INTO task_dependencies (task_id, depends_on_task_id)
SELECT $1, dep_id
FROM unnest($2::bigint[]) AS dep_id
WHERE dep_id != $1
ON CONFLICT DO NOTHING
RETURNING depends_on_task_id
`

type AddTaskDependenciesParams struct {
	TaskID  int64
	Column2 []int64
}

func (q *Queries) AddTaskDependencies(ctx context.Context, arg AddTaskDependenciesParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, addTaskDependencies, arg.TaskID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var depends_on_task_id int64
		if err := rows.Scan(&depends_on_task_id); err != nil {
			return nil, err
		}
		items = append(items, depends_on_task_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTaskDependencies = `-- name: DeleteTaskDependencies :many
DELETE FROM task_dependencies
WHERE task_id = $1 AND depends_on_task_id = ANY($2::bigint[])
RETURNING depends_on_task_id
`

type DeleteTaskDependenciesParams struct {
	TaskID  int64
	Column2 []int64
}

func (q *Queries) DeleteTaskDependencies(ctx context.Context, arg DeleteTaskDependenciesParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, deleteTaskDependencies, arg.TaskID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var depends_on_task_id int64
		if err := rows.Scan(&depends_on_task_id); err != nil {
			return nil, err
		}
		items = append(items, depends_on_task_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTasks = `-- name: DeleteTasks :many
DELETE FROM tasks
WHERE user_id = $1 AND id = ANY($2::bigint[])
RETURNING id
`

type DeleteTasksParams struct {
	UserID  uuid.UUID
	Column2 []int64
}

func (q *Queries) DeleteTasks(ctx context.Context, arg DeleteTasksParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, deleteTasks, arg.UserID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByUserID = `-- name: GetTasksByUserID :many
SELECT 
  t.id, t.user_id, t.task, t.selected, t.ttc, t.live_time, t.due_date, t.efficiency, t.parent_thread, t.waste, t.eta, t.weight, t.status, t.live_time_stamp, t.last_complete_time, t.last_incomplete_time, t.is_live,
  COALESCE(ARRAY_AGG(td.depends_on_task_id) FILTER (WHERE td.depends_on_task_id IS NOT NULL), ARRAY[]::BIGINT[])::BIGINT[] AS dependencies
FROM tasks t
LEFT JOIN task_dependencies td ON t.id = td.task_id
WHERE t.user_id = $1
GROUP BY t.id
ORDER BY t.id
`

type GetTasksByUserIDRow struct {
	ID                 int64
	UserID             uuid.UUID
	Task               string
	Selected           bool
	Ttc                float64
	LiveTime           float64
	DueDate            time.Time
	Efficiency         float64
	ParentThread       string
	Waste              float64
	Eta                time.Time
	Weight             int32
	Status             string
	LiveTimeStamp      sql.NullTime
	LastCompleteTime   time.Time
	LastIncompleteTime time.Time
	IsLive             bool
	Dependencies       []int64
}

func (q *Queries) GetTasksByUserID(ctx context.Context, userID uuid.UUID) ([]GetTasksByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksByUserIDRow
	for rows.Next() {
		var i GetTasksByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Task,
			&i.Selected,
			&i.Ttc,
			&i.LiveTime,
			&i.DueDate,
			&i.Efficiency,
			&i.ParentThread,
			&i.Waste,
			&i.Eta,
			&i.Weight,
			&i.Status,
			&i.LiveTimeStamp,
			&i.LastCompleteTime,
			&i.LastIncompleteTime,
			&i.IsLive,
			pq.Array(&i.Dependencies),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isTaskOwnedByUser = `-- name: IsTaskOwnedByUser :one
SELECT 1 FROM tasks
WHERE id = $1 AND user_id = $2
`

type IsTaskOwnedByUserParams struct {
	ID     int64
	UserID uuid.UUID
}

func (q *Queries) IsTaskOwnedByUser(ctx context.Context, arg IsTaskOwnedByUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, isTaskOwnedByUser, arg.ID, arg.UserID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const pingDB = `-- name: PingDB :one

SELECT 1
`

// Health related stuff...
func (q *Queries) PingDB(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, pingDB)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const refreshAllTasks = `-- name: RefreshAllTasks :many
UPDATE tasks
SET
  live_time = 0,
  status = 'incomplete',
  last_complete_time = NOW(),
  last_incomplete_time = NOW(),
  is_live = false
WHERE user_id = $1
RETURNING id
`

func (q *Queries) RefreshAllTasks(ctx context.Context, userID uuid.UUID) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, refreshAllTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshTask = `-- name: RefreshTask :one

UPDATE tasks
SET
  live_time = 0,
  status = 'incomplete',
  last_complete_time = NOW(),
  last_incomplete_time = NOW(),
  is_live = false
WHERE id = $1 AND user_id = $2
RETURNING id
`

type RefreshTaskParams struct {
	ID     int64
	UserID uuid.UUID
}

// Refresh Task related stuff...
func (q *Queries) RefreshTask(ctx context.Context, arg RefreshTaskParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, refreshTask, arg.ID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET task = $3,
    selected = $4,
    ttc = $5,
    live_time = $6,
    due_date = $7,
    efficiency = $8,
    parent_thread = $9,
    waste = $10,
    eta = $11,
    weight = $12,
    status = $13,
    live_time_stamp = $14,
    last_complete_time = $15,
    last_incomplete_time = $16,
    is_live = $17
WHERE user_id = $1 AND id = $2
RETURNING id
`

type UpdateTaskParams struct {
	UserID             uuid.UUID
	ID                 int64
	Task               string
	Selected           bool
	Ttc                float64
	LiveTime           float64
	DueDate            time.Time
	Efficiency         float64
	ParentThread       string
	Waste              float64
	Eta                time.Time
	Weight             int32
	Status             string
	LiveTimeStamp      sql.NullTime
	LastCompleteTime   time.Time
	LastIncompleteTime time.Time
	IsLive             bool
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.UserID,
		arg.ID,
		arg.Task,
		arg.Selected,
		arg.Ttc,
		arg.LiveTime,
		arg.DueDate,
		arg.Efficiency,
		arg.ParentThread,
		arg.Waste,
		arg.Eta,
		arg.Weight,
		arg.Status,
		arg.LiveTimeStamp,
		arg.LastCompleteTime,
		arg.LastIncompleteTime,
		arg.IsLive,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskDueDate = `-- name: UpdateTaskDueDate :one
UPDATE tasks SET due_date = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskDueDateParams struct {
	DueDate time.Time
	UserID  uuid.UUID
	ID      int64
}

func (q *Queries) UpdateTaskDueDate(ctx context.Context, arg UpdateTaskDueDateParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskDueDate, arg.DueDate, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskEfficiency = `-- name: UpdateTaskEfficiency :one
UPDATE tasks SET efficiency = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskEfficiencyParams struct {
	Efficiency float64
	UserID     uuid.UUID
	ID         int64
}

func (q *Queries) UpdateTaskEfficiency(ctx context.Context, arg UpdateTaskEfficiencyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskEfficiency, arg.Efficiency, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskEta = `-- name: UpdateTaskEta :one
UPDATE tasks SET eta = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskEtaParams struct {
	Eta    time.Time
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskEta(ctx context.Context, arg UpdateTaskEtaParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskEta, arg.Eta, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskIsLive = `-- name: UpdateTaskIsLive :one
UPDATE tasks SET is_live = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskIsLiveParams struct {
	IsLive bool
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskIsLive(ctx context.Context, arg UpdateTaskIsLiveParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskIsLive, arg.IsLive, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskLastCompleteTime = `-- name: UpdateTaskLastCompleteTime :one
UPDATE tasks SET last_complete_time = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskLastCompleteTimeParams struct {
	LastCompleteTime time.Time
	UserID           uuid.UUID
	ID               int64
}

func (q *Queries) UpdateTaskLastCompleteTime(ctx context.Context, arg UpdateTaskLastCompleteTimeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskLastCompleteTime, arg.LastCompleteTime, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskLastIncompleteTime = `-- name: UpdateTaskLastIncompleteTime :one
UPDATE tasks SET last_incomplete_time = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskLastIncompleteTimeParams struct {
	LastIncompleteTime time.Time
	UserID             uuid.UUID
	ID                 int64
}

func (q *Queries) UpdateTaskLastIncompleteTime(ctx context.Context, arg UpdateTaskLastIncompleteTimeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskLastIncompleteTime, arg.LastIncompleteTime, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskLiveTime = `-- name: UpdateTaskLiveTime :one
UPDATE tasks SET live_time = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskLiveTimeParams struct {
	LiveTime float64
	UserID   uuid.UUID
	ID       int64
}

func (q *Queries) UpdateTaskLiveTime(ctx context.Context, arg UpdateTaskLiveTimeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskLiveTime, arg.LiveTime, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskLiveTimeStamp = `-- name: UpdateTaskLiveTimeStamp :one
UPDATE tasks SET live_time_stamp = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskLiveTimeStampParams struct {
	LiveTimeStamp sql.NullTime
	UserID        uuid.UUID
	ID            int64
}

func (q *Queries) UpdateTaskLiveTimeStamp(ctx context.Context, arg UpdateTaskLiveTimeStampParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskLiveTimeStamp, arg.LiveTimeStamp, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskParentThread = `-- name: UpdateTaskParentThread :one
UPDATE tasks SET parent_thread = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskParentThreadParams struct {
	ParentThread string
	UserID       uuid.UUID
	ID           int64
}

func (q *Queries) UpdateTaskParentThread(ctx context.Context, arg UpdateTaskParentThreadParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskParentThread, arg.ParentThread, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskSelected = `-- name: UpdateTaskSelected :one
UPDATE tasks SET selected = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskSelectedParams struct {
	Selected bool
	UserID   uuid.UUID
	ID       int64
}

func (q *Queries) UpdateTaskSelected(ctx context.Context, arg UpdateTaskSelectedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskSelected, arg.Selected, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks SET status = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskStatusParams struct {
	Status string
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskStatus, arg.Status, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskTTC = `-- name: UpdateTaskTTC :one
UPDATE tasks SET ttc = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskTTCParams struct {
	Ttc    float64
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskTTC(ctx context.Context, arg UpdateTaskTTCParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskTTC, arg.Ttc, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskText = `-- name: UpdateTaskText :one

UPDATE tasks SET task = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskTextParams struct {
	Task   string
	UserID uuid.UUID
	ID     int64
}

// UpdateTaskField related stuff...
func (q *Queries) UpdateTaskText(ctx context.Context, arg UpdateTaskTextParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskText, arg.Task, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskWaste = `-- name: UpdateTaskWaste :one
UPDATE tasks SET waste = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskWasteParams struct {
	Waste  float64
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskWaste(ctx context.Context, arg UpdateTaskWasteParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskWaste, arg.Waste, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTaskWeight = `-- name: UpdateTaskWeight :one
UPDATE tasks SET weight = $1 WHERE user_id = $2 AND id = $3 RETURNING id
`

type UpdateTaskWeightParams struct {
	Weight int32
	UserID uuid.UUID
	ID     int64
}

func (q *Queries) UpdateTaskWeight(ctx context.Context, arg UpdateTaskWeightParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTaskWeight, arg.Weight, arg.UserID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}
