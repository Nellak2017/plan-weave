// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_types from "rescript/lib/es6/js_types.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ConstantsJs from "./constants.js";

var millisecondsPerHour = ConstantsJs.MILLISECONDS_PER_HOUR;

var millisecondsPerDay = ConstantsJs.MILLISECONDS_PER_DAY;

var taskStatuses = ConstantsJs.TASK_STATUSES;

function logFx(result, postConditionsOpt, defaultVal, loggerOpt, warningOpt) {
  var postConditions = postConditionsOpt !== undefined ? postConditionsOpt : (function (param) {
        return true;
      });
  var logger = loggerOpt !== undefined ? loggerOpt : (function (prim) {
        console.warn(prim);
      });
  var warning = warningOpt !== undefined ? warningOpt : "Unsafe input detected in this function. Logging and returning default";
  if (postConditions(result)) {
    return result;
  } else {
    Curry._1(logger, warning);
    return defaultVal;
  }
}

function devLog(result, config, logFxOpt) {
  var logFx$1 = logFxOpt !== undefined ? logFxOpt : logFx;
  return logFx$1(result, config.postConditions, config.defaultVal, undefined, config.warning(result));
}

function isNullOrUndefined(val) {
  if (val == null) {
    return true;
  } else {
    return Caml_obj.notequal(val, val);
  }
}

function floatToStringNullable(num, fallbackOpt) {
  var fallback = fallbackOpt !== undefined ? fallbackOpt : "undefined or null";
  if (isNullOrUndefined(num)) {
    return fallback;
  } else {
    return num.toString();
  }
}

function step(x, thresholdOpt) {
  var threshold = thresholdOpt !== undefined ? thresholdOpt : 0;
  if (x > threshold) {
    return 1;
  } else {
    return 0;
  }
}

function hoursToSeconds(hours) {
  return hours * 60.0 * 60.0;
}

function hoursToMillis(hours) {
  return hours * 60000.0 * 60.0;
}

function millisToHours(milliseconds) {
  return milliseconds / 60000.0 / 60.0;
}

function add(start, hours) {
  return new Date(start.getTime() + hoursToMillis(hours));
}

function subtract(time, eta) {
  return millisToHours(time.getTime() - eta.getTime());
}

function dateToToday(start) {
  var now = new Date(Date.now());
  if (!(Caml_obj.lessequal(new Date(0.0), start) && Number.isFinite(start.valueOf()))) {
    return {
            TAG: "Error",
            _0: "Invalid input. Expected a Date for dateToToday function."
          };
  }
  var initOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).valueOf();
  var initOfStart = new Date(start.getFullYear(), start.getMonth(), start.getDate()).valueOf();
  return {
          TAG: "Ok",
          _0: new Date(initOfToday + (start.valueOf() - initOfStart))
        };
}

function calculateEfficiency(startTime, endTime, ttcHours) {
  var timeDiff = endTime - startTime;
  var efficiencyFormula = hoursToSeconds(ttcHours) / (timeDiff * step(timeDiff, undefined));
  var parametersString = "\nstartTime = " + floatToStringNullable(startTime, undefined) + "}\nendTime = " + floatToStringNullable(endTime, undefined) + "}\nttcHours = " + floatToStringNullable(ttcHours, undefined) + "}";
  var undefinedString = "Type Error. Expected (startTime, endTime, ttcHours := Not undefined)." + parametersString;
  var invalidTypeString = "Type Error. Expected (startTime, endTime, ttcHours := Float)." + parametersString;
  var parameterRangeString = "Invalid input parameter Range.";
  var beyondMaxDateString = parameterRangeString + " Expected (startTime, endTime := [0,max safe date (8.64e15)))." + parametersString;
  var belowZeroErrorString = parameterRangeString + " Expected (startTime, endTime := [0,max safe date (8.64e15)]), (ttcHours := (0,24])." + parametersString;
  var moreThanDayString = parameterRangeString + " Expected (endTime - startTime <= 86400), (ttcHours <= 24)." + parametersString;
  var startEqualsEndString = parameterRangeString + " Expected (startTime === endTime)." + parametersString;
  var startGreaterEndString = parameterRangeString + " Expected (startTime < endTime).No longer supporting domain extension." + parametersString;
  var unknownErrorString = "Unknown Error has occurred in calculateEfficiency function." + parametersString;
  var undefinedError = startTime === undefined || endTime === undefined || ttcHours === undefined;
  var invalidInputTypeError = !Number.isFinite(startTime) || !Number.isFinite(endTime) || !Number.isFinite(ttcHours);
  if (undefinedError) {
    return {
            TAG: "Error",
            _0: undefinedString
          };
  } else if (invalidInputTypeError) {
    return {
            TAG: "Error",
            _0: invalidTypeString
          };
  } else if (startTime < 0.0 || endTime < 0.0 || ttcHours <= 0.0) {
    return {
            TAG: "Error",
            _0: belowZeroErrorString
          };
  } else if (startTime > 8.64e15 || endTime > 8.64e15) {
    return {
            TAG: "Error",
            _0: beyondMaxDateString
          };
  } else if (endTime - startTime > 86400.0 || ttcHours > 24.0) {
    return {
            TAG: "Error",
            _0: moreThanDayString
          };
  } else if (startTime === endTime) {
    return {
            TAG: "Error",
            _0: startEqualsEndString
          };
  } else if (startTime > endTime || !Number.isFinite(efficiencyFormula)) {
    return {
            TAG: "Error",
            _0: startGreaterEndString
          };
  } else if (startTime < endTime) {
    return {
            TAG: "Ok",
            _0: efficiencyFormula
          };
  } else {
    return {
            TAG: "Error",
            _0: unknownErrorString
          };
  }
}

function validateTransformation(task, schema, customErrorMessage) {
  var customErrorProcessed = customErrorMessage !== undefined ? customErrorMessage : "";
  var str = JSON.stringify(task);
  var errorMessage = str !== undefined ? customErrorProcessed + " task : " + str : "Failed to stringify task for error message";
  if (schema.isValidSync(task, {
          strict: true
        })) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: errorMessage
          };
  }
}

function isTimestampFromToday(today, timestamp, secondsFromStartOpt) {
  var secondsFromStart = secondsFromStartOpt !== undefined ? secondsFromStartOpt : 86400.0;
  var todayDate = new Date(today.valueOf());
  var initOfToday = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate(), 0, 0, 0);
  var startOfTodaySeconds = initOfToday.valueOf() / 1000;
  if (startOfTodaySeconds <= timestamp) {
    return timestamp <= startOfTodaySeconds + secondsFromStart;
  } else {
    return false;
  }
}

function formatTimeLeft(currentTimeOpt, endTimeOpt, timeDifferenceOpt, minuteTextOpt, hourTextOpt, hourText2Opt, overNightModeOpt) {
  var currentTime = currentTimeOpt !== undefined ? Caml_option.valFromOption(currentTimeOpt) : new Date();
  var endTime = endTimeOpt !== undefined ? Caml_option.valFromOption(endTimeOpt) : new Date();
  var timeDifference = timeDifferenceOpt !== undefined ? timeDifferenceOpt : 0.0;
  var minuteText = minuteTextOpt !== undefined ? minuteTextOpt : "minutes left";
  var hourText = hourTextOpt !== undefined ? hourTextOpt : "hour";
  var hourText2 = hourText2Opt !== undefined ? hourText2Opt : "hours left";
  var overNightMode = overNightModeOpt !== undefined ? overNightModeOpt : false;
  var calculateTimeDifference = function (endTime, currentTimeOpt, timeDifferenceOpt, overNightModeOpt) {
    var currentTime = currentTimeOpt !== undefined ? Caml_option.valFromOption(currentTimeOpt) : new Date();
    var timeDifference = timeDifferenceOpt !== undefined ? timeDifferenceOpt : 0;
    var overNightMode = overNightModeOpt !== undefined ? overNightModeOpt : false;
    var adjustedEndTimeValue = overNightMode ? add(endTime, 24).valueOf() : endTime.valueOf();
    if (Number.isFinite(timeDifference)) {
      if (Js_types.test(overNightMode, "Boolean")) {
        if (timeDifference > 0) {
          return {
                  TAG: "Ok",
                  _0: timeDifference * millisecondsPerHour
                };
        } else if (timeDifference === 0) {
          return {
                  TAG: "Ok",
                  _0: Math.max(0, adjustedEndTimeValue - currentTime.valueOf())
                };
        } else {
          return {
                  TAG: "Error",
                  _0: "Unspecified error.\nendTime=" + String(endTime.valueOf()) + "\ncurrentTime=" + String(currentTime.valueOf()) + "\ntimeDifference=" + String(timeDifference)
                };
        }
      } else {
        return {
                TAG: "Error",
                _0: "overNightMode must be a boolean"
              };
      }
    } else {
      return {
              TAG: "Error",
              _0: "timeDifference must be a number"
            };
    }
  };
  return Belt_Result.flatMap(calculateTimeDifference(endTime, Caml_option.some(currentTime), timeDifference, overNightMode), (function (res) {
                var totalHours = res / millisecondsPerHour;
                var timeLeftInHours = Math.floor(totalHours);
                var timeLeftInMinutes = Math.floor((totalHours - timeLeftInHours) * 60);
                var parsedString;
                if (timeLeftInHours > 0) {
                  var secondsText = timeLeftInHours > 1 ? "s" : "";
                  parsedString = timeLeftInMinutes > 0 ? String(timeLeftInHours) + " " + hourText + secondsText + " " + String(timeLeftInMinutes) + " " + minuteText : String(timeLeftInHours) + " " + hourText2;
                } else {
                  parsedString = String(timeLeftInMinutes) + " " + minuteText;
                }
                if (Js_types.test(parsedString, "String")) {
                  return {
                          TAG: "Ok",
                          _0: parsedString
                        };
                } else {
                  return {
                          TAG: "Error",
                          _0: "Invalid input in format Time"
                        };
                }
              }))._0;
}

function isRequired(field, schema) {
  return Belt_Option.getWithDefault(Belt_Option.map(Belt_Option.flatMap(schema.describe(), (function (v) {
                        return Js_dict.get(v.fields, field);
                      })), (function (fieldInfo) {
                    return !fieldInfo.optional;
                  })), false);
}

function requiredFields(schema) {
  return Belt_Option.getWithDefault(Belt_Option.map(Belt_Option.map(Belt_Option.map(Belt_Option.map(schema.describe(), (function (v) {
                                return v.fields;
                              })), (function (fields) {
                            return Object.keys(fields);
                          })), (function (keys) {
                        return Belt_Array.map(keys, (function (field) {
                                      if (isRequired(field, schema)) {
                                        return field;
                                      }
                                      
                                    }));
                      })), (function (fields) {
                    return Belt_Array.keepMap(fields, (function (x) {
                                  return x;
                                }));
                  })), []);
}

function etaList(taskList, startOpt) {
  var start = startOpt !== undefined ? startOpt : 0;
  return Belt_Array.reduce(taskList, [start], (function (acc, task) {
                var t = task.ttc;
                var ttc = t !== undefined ? t : 0.1;
                var t$1 = Belt_Array.get(acc, -1);
                var end = t$1 !== undefined ? t$1 : 0;
                return Belt_Array.concat(Belt_Array.slice(acc, 0, acc.length), [end + ttc]);
              }));
}

export {
  millisecondsPerHour ,
  millisecondsPerDay ,
  taskStatuses ,
  logFx ,
  devLog ,
  isNullOrUndefined ,
  floatToStringNullable ,
  step ,
  hoursToSeconds ,
  hoursToMillis ,
  millisToHours ,
  add ,
  subtract ,
  dateToToday ,
  calculateEfficiency ,
  validateTransformation ,
  isTimestampFromToday ,
  formatTimeLeft ,
  isRequired ,
  requiredFields ,
  etaList ,
}
/* millisecondsPerHour Not a pure module */
